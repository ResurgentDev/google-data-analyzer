#!/usr/bin/env python3
"""
Test MBOX Generator

This script generates test .mbox files with a variety of email formats, headers, content types,
and attachments for testing the Google Data Analyzer.

Usage:
    python mbox_generator.py --count [16|32] [--output OUTPUT_PATH]

The script creates reproducible test data with:
- Plain text emails
- HTML emails
- Mixed content emails
- Various charsets (UTF-8, ASCII, ISO-8859-1)
- Header variations (From, To, CC, BCC, Reply-To, etc.)
- Attachment variations (text, PDF, images)

By default, files are generated in the tests/data directory as sample16.mbox or sample32.mbox.
"""

import os
import sys
import random
import argparse
import base64
import mailbox
import datetime
import time
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
from email.mime.image import MIMEImage
from email.mime.base import MIMEBase
from email.utils import formatdate, make_msgid, formataddr
from email.header import Header
import logging
from pathlib import Path


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Constants
DEFAULT_COUNT = 16
DEFAULT_OUTPUT = None  # Use default naming convention
VALID_COUNTS = [16, 32]
SEED = 42  # Fixed seed for reproducibility

# Common constants for email generation
DOMAINS = ["example.com", "test.org", "mail.net", "company.co", "domain.io"]
FROM_ADDRESSES = [
    ("John Doe", "john.doe@example.com"),
    ("Jane Smith", "jane@test.org"),
    ("Alex Johnson", "alex@mail.net"),
    ("Maria Rodriguez", "maria@company.co"),
    ("Test User", "test@domain.io"),
    ("Jörg Müller", "joerg@german-company.de"),  # Non-ASCII
    ("名無しの権兵衛", "nanashi@jp-company.jp"),  # Japanese
    ("Ivan Petrov", "ivan@russian-company.ru"),  # Russian-like 
]
TO_ADDRESSES = [
    ("Support Team", "support@example.com"),
    ("Info", "info@test.org"),
    ("Helpdesk", "help@mail.net"),
    ("Contact", "contact@company.co"),
    ("Admin", "admin@domain.io"),
    ("Development Team", "dev@example.com"),
    ("Sales Team", "sales@company.co"),
    ("HR Department", "hr@test.org"),
]
CC_ADDRESSES = [
    ("Manager", "manager@example.com"),
    ("Team Lead", "lead@test.org"),
    ("Project Owner", "project@mail.net"),
]
BCC_ADDRESSES = [
    ("Archive", "archive@example.com"),
    ("Records", "records@test.org"),
]
SUBJECT_TEMPLATES = [
    "Test Email {id}",
    "Important: Test Message {id}",
    "Notification: System Update {id}",
    "Hello from Test Script {id}",
    "Automated Test Email {id}",
    "Meeting Summary {id}",
    "Project Update {id}",
    "Weekly Report {id}",
    "Monthly Newsletter {id}",
    "Welcome to our platform {id}",
    "Your account summary {id}",
    "Security Alert {id}",
    "Password Reset {id}",
    "Upcoming Events {id}",
    "Breaking News {id}",
    "特別なお知らせ {id}",  # Japanese
    "Spécial Annonce {id}",  # French
    "Специальное уведомление {id}",  # Russian
]
PLAINTEXT_BODIES = [
    "This is a simple test email with plain text content. Email ID: {id}",
    
    """Dear recipient,

This email is automatically generated for testing purposes.
Please ignore this message.

Best regards,
Test System
Email ID: {id}""",
    
    """NOTICE: This is a test email.
All content in this message is fictional and generated for testing.
Please do not reply to this message.
Email ID: {id}""",

    """Hello,

This is an example of a plaintext email for testing the Google Data Analyzer.
The system should correctly extract and categorize this message.

Some key features to test:
- Header processing
- Content extraction
- Charset handling
- Line breaks and formatting

Email ID: {id}
""",
    
    """AUTOMATED MESSAGE - DO NOT REPLY

This message was generated by an automated system for testing purposes.
If you received this message in error, please disregard it.

Email ID: {id}
"""
]
HTML_BODIES = [
    """<html>
<head><title>Test Email {id}</title></head>
<body>
<h1>Test Email {id}</h1>
<p>This is a simple test email with HTML content.</p>
</body>
</html>""",
    
    """<html>
<head><title>Automated Test Message</title></head>
<body>
<h1>Test Notification</h1>
<p>Dear recipient,</p>
<p>This email is automatically generated for testing purposes.</p>
<p>Please ignore this message.</p>
<p>Email ID: {id}</p>
<hr>
<p><small>Test System</small></p>
</body>
</html>""",
    
    """<html>
<head><title>Test Email with Formatting</title></head>
<body>
<h1>Test Email with Formatting</h1>
<p>This email contains various HTML elements to test the parser:</p>
<ul>
  <li>Bold text: <b>This is bold</b></li>
  <li>Italic text: <i>This is italic</i></li>
  <li>Links: <a href="http://example.com">Example Website</a></li>
  <li>Email ID: {id}</li>
</ul>
<div style="background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc;">
  <p>This is a styled div element.</p>
</div>
</body>
</html>""",
    
    """<html>
<head>
<meta charset="UTF-8">
<title>Complex HTML Email</title>
<style>
  body { font-family: "Arial", "sans-serif"; }
  .header { background-color: #4285f4; color: white; padding: 20px; }
  .content { padding: 20px; }
  .footer { background-color: #f2f2f2; padding: 10px; font-size: 12px; }
</style>
</head>
<body>
<div class="header">
  <h1>Test Email System</h1>
</div>
<div class="content">
  <h2>Complex HTML Email Test</h2>
  <p>This email tests more complex HTML structures and CSS styling.</p>
  <p>The parser should be able to extract content from various nested elements.</p>
  <table border="1" cellpadding="5">
    <tr>
      <th>Item</th><th>Value</th>
    </tr>
    <tr>
      <td>Email ID</td><td>{id}</td>
    </tr>
    <tr>
      <td>Generated</td><td>Automatically</td>
    </tr>
  </table>
</div>
<div class="footer">
  <p>This is an automated test email. Please do not reply.</p>
</div>
</body>
</html>"""
]
TEXT_ATTACHMENTS = [
    ("attachment.txt", "This is a text file attachment for testing.\nEmail ID: {id}"),
    ("notes.txt", "Important notes about the test email system.\nEmail ID: {id}"),
    ("data.txt", "Sample data for testing attachments.\nLine 1\nLine 2\nLine 3\nEmail ID: {id}"),
]
MOCK_PDF_CONTENT = """
%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>
endobj
4 0 obj
<< /Length 68 >>
stream
BT
/F1 12 Tf
100 700 Td
(Test PDF attachment for email {id}) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f
0000000010 00000 n
0000000060 00000 n
0000000119 00000 n
0000000208 00000 n
trailer
<< /Size 5 /Root 1 0 R >>
startxref
327
%%EOF
"""
MOCK_IMAGE_DATA = """
iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJ
bWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdp
bj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6
eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0
NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJo
dHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlw
dGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAv
IiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RS
ZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpD
cmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNl
SUQ9InhtcC5paWQ6MjY1OTU0QjYyQzM0MTFFQTlBRjE5NkY5RjgwNUJCOTgiIHhtcE1NOkRvY3Vt
ZW50SUQ9InhtcC5kaWQ6MjY1OTU0QjcyQzM0MTFFQTlBRjE5NkY5RjgwNUJCOTgiPiA8eG1wTU06
RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyNjU5NTRCNDJDMTFFQQ==
"""


def parse_arguments():
    """Parse command line arguments for the mbox generator."""
    parser = argparse.ArgumentParser(description="Generate test mbox files for email analysis testing")
    parser.add_argument("--count", type=int, choices=VALID_COUNTS, default=DEFAULT_COUNT,
                        help=f"Number of emails to generate (valid options: {', '.join(map(str, VALID_COUNTS))})")
    parser.add_argument("--output", type=str, default=DEFAULT_OUTPUT,
                        help="Output file path (default: sample{count}.mbox in the script directory)")
    
    args = parser.parse_args()
    args = parser.parse_args()
    
    # Set default output path if not specified
    if args.output is None:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Set the output path to tests/data directory
        tests_data_dir = os.path.join(os.path.dirname(os.path.dirname(script_dir)), "tests", "data")
        args.output = os.path.join(tests_data_dir, f"sample{args.count}.mbox")
    
    return args

def setup_random_seed():
    """Set up a fixed random seed for reproducible results."""
    random.seed(SEED)


def get_random_date(start_year=2020, end_year=2023):
    """Generate a random date string in RFC 2822 format."""
    year = random.randint(start_year, end_year)
    month = random.randint(1, 12)
    day = random.randint(1, 28)  # Using 28 to avoid month-end issues
    hour = random.randint(0, 23)
    minute = random.randint(0, 59)
    second = random.randint(0, 59)
    
    date_obj = datetime.datetime(year, month, day, hour, minute, second)
    
    # Randomly choose between RFC 2822 format and ISO format
    if random.choice([True, False]):
        return formatdate(time.mktime(date_obj.timetuple()), localtime=True)
    else:
        return date_obj.isoformat(' ')


def create_plaintext_email(email_id):
    """Create a plain text email with random headers."""
    msg = MIMEText(random.choice(PLAINTEXT_BODIES).format(id=email_id), 'plain')
    
    # Choose random charset
    charset = random.choice(['utf-8', 'ascii', 'iso-8859-1'])
    msg.set_charset(charset)
    
    # Add standard headers
    from_email = add_standard_headers(msg, email_id)
    
    # Add additional headers specific to plaintext emails
    if random.choice([True, False]):
        bcc_name, bcc_email = random.choice(BCC_ADDRESSES)
        msg['BCC'] = formataddr((bcc_name, bcc_email))
    
    # Randomly add auto-reply header
    if random.choice([True, False]):
        msg['Auto-Submitted'] = 'auto-replied'
    
    # Randomly add encoded headers for non-ASCII content
    if random.choice([True, False]) and charset == 'utf-8':
        # Add a non-ASCII subject header
        if random.choice([True, False]):
            non_ascii_subject = random.choice([
                "测试电子邮件 {id}",  # Chinese
                "テスト メール {id}",  # Japanese
                "Тестовое письмо {id}"  # Russian
            ]).format(id=email_id)
            msg.replace_header('Subject', str(Header(non_ascii_subject, 'utf-8')))
    
    return msg


def add_standard_headers(msg, email_id, content_type=None):
    """Add standard headers to an email message."""
    from_name, from_email = random.choice(FROM_ADDRESSES)
    to_name, to_email = random.choice(TO_ADDRESSES)
    
    msg['From'] = formataddr((from_name, from_email))
    msg['To'] = formataddr((to_name, to_email))
    msg['Subject'] = random.choice(SUBJECT_TEMPLATES).format(id=email_id)
    msg['Date'] = get_random_date()
    msg['Message-ID'] = make_msgid(domain=from_email.split('@')[1])
    
    if content_type:
        msg['Content-Type'] = content_type
    
    # Randomly add CC or Reply-To
    if random.choice([True, False]):
        cc_name, cc_email = random.choice(CC_ADDRESSES)
        msg['CC'] = formataddr((cc_name, cc_email))
    
    if random.choice([True, False]):
        msg['Reply-To'] = formataddr((from_name, from_email))
    
    # Return from_email for potential use in other headers
    return from_email

def create_html_email(email_id):
    """Create an HTML email with random headers."""
    try:
        html_content = random.choice(HTML_BODIES).format(id=email_id)
        msg = MIMEText(html_content, 'html')
        
        # Choose random charset
        charset = random.choice(['utf-8', 'ascii', 'iso-8859-1'])
        msg.set_charset(charset)
        
        # Add headers
        add_standard_headers(msg, email_id, f'text/html; charset={charset}')
        
    except Exception as e:
        logger.error(f"Error creating HTML email {email_id}: {e}")
        # Fall back to plain text if HTML generation fails
        return create_plaintext_email(email_id)
        
    return msg

def create_mixed_content_email(email_id):
    """Create a multipart email with both plain text and HTML content."""
    msg = MIMEMultipart('alternative')
    
    # Add plain text part
    text_part = MIMEText(random.choice(PLAINTEXT_BODIES).format(id=email_id), 'plain')
    charset_text = random.choice(['utf-8', 'ascii', 'iso-8859-1'])
    text_part.set_charset(charset_text)
    
    # Add HTML part with error handling
    try:
        html_content = random.choice(HTML_BODIES).format(id=email_id)
        html_part = MIMEText(html_content, 'html')
    except Exception as e:
        logger.error(f"Error generating HTML part for email {email_id}: {e}")
        # Fall back to a simple HTML message if complex HTML generation fails
        html_part = MIMEText(f"<html><body><p>Fallback HTML content for email {email_id}</p></body></html>", 'html')
    charset_html = random.choice(['utf-8', 'ascii', 'iso-8859-1'])
    html_part.set_charset(charset_html)
    
    # Add parts to the message
    msg.attach(text_part)
    msg.attach(html_part)
    
    # Add standard headers
    add_standard_headers(msg, email_id)
    
    # Additional random headers specific to mixed content
    if random.choice([True, False]):
        cc_names = [name for name, _ in random.sample(CC_ADDRESSES, random.randint(1, len(CC_ADDRESSES)))]
        cc_emails = [email for _, email in random.sample(CC_ADDRESSES, random.randint(1, len(CC_ADDRESSES)))]
        msg['CC'] = ', '.join([formataddr((name, email)) for name, email in zip(cc_names, cc_emails)])
    
    return msg

def add_attachment(msg, attachment_type, email_id):
    """Add an attachment to an email message based on the specified type."""
    if attachment_type == "text":
        # Add text attachment
        attachment_name, attachment_content = random.choice(TEXT_ATTACHMENTS)
        attachment_content = attachment_content.format(id=email_id)
        attachment = MIMEText(attachment_content)
        attachment.add_header('Content-Disposition', 'attachment', filename=attachment_name)
        msg.attach(attachment)
    elif attachment_type == "pdf":
        # Add PDF attachment
        pdf_content = MOCK_PDF_CONTENT.format(id=email_id).encode('utf-8')
        attachment = MIMEApplication(pdf_content, _subtype='pdf')
        attachment.add_header('Content-Disposition', 'attachment', filename=f'document_{email_id}.pdf')
        msg.attach(attachment)
    elif attachment_type == "image":
        # Add image attachment
        image_data = base64.b64decode(MOCK_IMAGE_DATA)
        attachment = MIMEImage(image_data)
        attachment.add_header('Content-Disposition', 'attachment', filename=f'image_{email_id}.png')
        msg.attach(attachment)
    return msg

def create_email_with_text_attachment(email_id):
    """Create an email with a text file attachment."""
    msg = MIMEMultipart()
    
    # Add main body
    body = random.choice(PLAINTEXT_BODIES).format(id=email_id)
    msg.attach(MIMEText(body, 'plain'))
    
    # Add attachment
    add_attachment(msg, "text", email_id)
    
    # Add headers
    add_standard_headers(msg, email_id)
    
    return msg


def create_email_with_pdf_attachment(email_id):
    """Create an email with a PDF file attachment (mocked)."""
    msg = MIMEMultipart()
    
    # Add main body
    body = random.choice(PLAINTEXT_BODIES).format(id=email_id)
    msg.attach(MIMEText(body, 'plain'))
    
    # Add PDF attachment
    add_attachment(msg, "pdf", email_id)
    
    # Add headers
    from_email = add_standard_headers(msg, email_id)
    msg.replace_header('Subject', f"Email with PDF attachment {email_id}")
    
    return msg


def create_email_with_image_attachment(email_id):
    """Create an email with an image file attachment (mocked)."""
    msg = MIMEMultipart()
    
    # Add main body
    body = random.choice(PLAINTEXT_BODIES).format(id=email_id)
    msg.attach(MIMEText(body, 'plain'))
    
    # Add image attachment
    add_attachment(msg, "image", email_id)
    
    # Add headers
    from_email = add_standard_headers(msg, email_id)
    msg.replace_header('Subject', f"Email with image attachment {email_id}")
    
    return msg


def create_email_with_multiple_attachments(email_id):
    """Create an email with multiple attachments of different types."""
    msg = MIMEMultipart()
    
    # Add main body
    body = random.choice(PLAINTEXT_BODIES).format(id=email_id)
    msg.attach(MIMEText(body, 'plain'))
    
    # Add all attachment types
    add_attachment(msg, "text", email_id)
    add_attachment(msg, "pdf", email_id)
    add_attachment(msg, "image", email_id)
    
    # Add headers
    from_email = add_standard_headers(msg, email_id)
    msg.replace_header('Subject', f"Email with multiple attachments {email_id}")
    
    return msg


def generate_random_email(email_id):
    """Generate a random email of various types."""
    # Define email type distribution
    email_types = [
        (create_plaintext_email, 4),              # Plain text (weight: 4)
        (create_html_email, 3),                   # HTML only (weight: 3)
        (create_mixed_content_email, 3),          # Mixed content (weight: 3)
        (create_email_with_text_attachment, 2),   # Text attachment (weight: 2)
        (create_email_with_pdf_attachment, 2),    # PDF attachment (weight: 2)
        (create_email_with_image_attachment, 2),  # Image attachment (weight: 2)
        (create_email_with_multiple_attachments, 1) # Multiple attachments (weight: 1)
    ]
    
    # Calculate weights
    weights = [weight for _, weight in email_types]
    email_generators = [generator for generator, _ in email_types]
    
    # Choose random email type based on weights
    email_generator = random.choices(email_generators, weights=weights, k=1)[0]
    
    # Generate email
    try:
        return email_generator(email_id)
    except Exception as e:
        logger.error(f"Error generating email {email_id}: {e}")
        # Fallback to plaintext if other generation fails
        return create_plaintext_email(email_id)


def create_mbox_file(count, output_path):
    """Create an mbox file with the specified number of emails.
    
    Args:
        count: Number of emails to generate (16 or 32)
        output_path: Path to write the mbox file
        
    Returns:
        True if successful, False otherwise
    """
    # Ensure output directory exists
    output_dir = os.path.dirname(os.path.abspath(output_path))
    if not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir, exist_ok=True)
            logger.info(f"Created output directory: {output_dir}")
        except OSError as e:
            logger.error(f"Failed to create output directory: {e}")
            return False
    
    # Create or open the mbox file
    try:
        mbox = mailbox.mbox(output_path)
        mbox.clear()  # Clear existing content if any
        logger.info(f"Creating mbox file at: {output_path}")
    except Exception as e:
        logger.error(f"Failed to create mbox file: {e}")
        return False
        
    # Generate emails
    try:
        for i in range(1, count + 1):
            email_msg = generate_random_email(i)
            mbox.add(email_msg)
            if i % 5 == 0 or i == count:  # Log progress every 5 emails or at completion
                logger.info(f"Generated {i}/{count} emails")
                
        # Ensure changes are saved
        mbox.flush()
        mbox.close()
        
        # Verify the file exists and has content
        if not os.path.exists(output_path):
            logger.error(f"Failed to create output file: {output_path}")
            return False
            
        file_size = os.path.getsize(output_path)
        if file_size == 0:
            logger.error(f"Output file is empty: {output_path}")
            return False
            
        logger.info(f"Successfully created {count} emails in {output_path} ({file_size} bytes)")
        return True
        
    except Exception as e:
        logger.error(f"Error generating emails: {e}")
        # Try to close the file even if there was an error
        try:
            mbox.close()
        except:
            pass
        return False


def validate_mbox_file(file_path, expected_count):
    """Validate that the generated mbox file contains the expected number of emails.
    
    Args:
        file_path: Path to the mbox file
        expected_count: Expected number of emails
        
    Returns:
        True if valid, False otherwise
    """
    try:
        if not os.path.exists(file_path):
            logger.error(f"Mbox file not found: {file_path}")
            return False
            
        mbox = mailbox.mbox(file_path)
        actual_count = len(mbox)
        mbox.close()
        
        if actual_count != expected_count:
            logger.error(f"Mbox file contains {actual_count} emails, expected {expected_count}")
            return False
            
        logger.info(f"Validated mbox file: {file_path} contains {actual_count} emails")
        return True
        
    except Exception as e:
        logger.error(f"Error validating mbox file: {e}")
        return False


def main():
    """Main function to handle the command line interface."""
    try:
        # Parse arguments
        args = parse_arguments()
        
        # Setup reproducible random generation
        setup_random_seed()
        
        # Log start
        logger.info(f"Starting mbox generation: {args.count} emails to {args.output}")
        
        # Generate mbox file
        success = create_mbox_file(args.count, args.output)
        if not success:
            logger.error("Failed to generate mbox file")
            sys.exit(1)
            
        # Validate the generated file
        if not validate_mbox_file(args.output, args.count):
            logger.error("Generated file validation failed")
            sys.exit(2)
            
        logger.info("Mbox generation completed successfully")
        sys.exit(0)
        
    except KeyboardInterrupt:
        logger.info("Process interrupted by user")
        sys.exit(130)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
