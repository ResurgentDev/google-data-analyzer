#!/usr/bin/env python3
"""
Email Statistics Module

This module provides statistical analysis functions for email data, including:
- Basic statistical calculations (mean, median, mode)
- Email count statistics
- Header statistics (from, to, cc, bcc addresses, subjects)
- Content size statistics for email bodies
- Attachment statistics (types, sizes)
- Time-based statistics for email distribution

The module works with the data structures generated by the email analyzer.
"""

import statistics as py_stats
from collections import Counter, defaultdict
import datetime
from typing import List, Dict, Any, Union, Tuple, Optional


def calculate_mean(data: List[float]) -> float:
    """
    Calculate the arithmetic mean of a list of numbers.
    
    Args:
        data: List of numerical values
        
    Returns:
        float: The mean value or 0 if the list is empty
    """
    if not data:
        return 0
    return sum(data) / len(data)


def calculate_median(data: List[float]) -> float:
    """
    Calculate the median of a list of numbers.
    
    Args:
        data: List of numerical values
        
    Returns:
        float: The median value or 0 if the list is empty
    """
    if not data:
        return 0
    sorted_data = sorted(data)
    n = len(sorted_data)
    if n % 2 == 0:
        return (sorted_data[n//2 - 1] + sorted_data[n//2]) / 2
    return float(sorted_data[n//2])


def calculate_mode(data: List[Any]) -> Any:
    """
    Calculate the most common value in a list.
    
    Args:
        data: List of values
        
    Returns:
        Any: The most common value or None if the list is empty
    """
    if not data:
        return None
    
    counter = Counter(data)
    # Get most common element (mode)
    most_common = counter.most_common(1)
    if most_common:
        return most_common[0][0]
    return None


def format_size(size_bytes: float) -> str:
    """
    Formats a byte size into a human-readable string.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        str: Formatted size string
    """
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} PB"


def email_count_stats(count: int) -> Dict[str, int]:
    """
    Generate basic email count statistics.
    
    Args:
        count: Number of emails
        
    Returns:
        dict: Dictionary with email count statistics
    """
    return {"email_count": count}


def sender_stats(from_addresses: Counter) -> Dict[str, Any]:
    """
    Calculate statistics about email senders.
    
    Args:
        from_addresses: Counter of sender email addresses
        
    Returns:
        dict: Statistics about sender email addresses
    """
    if not from_addresses:
        return {}
    
    return {
        "top_senders": [
            {"address": addr, "count": count} 
            for addr, count in from_addresses.most_common(10)
        ],
        "unique_senders": len(from_addresses),
        "most_frequent_sender": from_addresses.most_common(1)[0][0] if from_addresses else None,
        "most_frequent_sender_count": from_addresses.most_common(1)[0][1] if from_addresses else 0
    }


def recipient_stats(to_addresses: Counter) -> Dict[str, Any]:
    """
    Calculate statistics about email recipients.
    
    Args:
        to_addresses: Counter of recipient email addresses
        
    Returns:
        dict: Statistics about recipient email addresses
    """
    if not to_addresses:
        return {}
    
    return {
        "top_recipients": [
            {"address": addr, "count": count} 
            for addr, count in to_addresses.most_common(10)
        ],
        "unique_recipients": len(to_addresses),
        "most_frequent_recipient": to_addresses.most_common(1)[0][0] if to_addresses else None,
        "most_frequent_recipient_count": to_addresses.most_common(1)[0][1] if to_addresses else 0
    }


def body_size_stats(sizes: List[int], content_type: str = "generic") -> Dict[str, Any]:
    """
    Calculate statistics about email body sizes.
    
    Args:
        sizes: List of body sizes in bytes
        content_type: Type of content (plain_text, html, etc.)
        
    Returns:
        dict: Statistics about body sizes
    """
    if not sizes:
        return {}
    
    total_size = sum(sizes)
    avg_size = total_size / len(sizes)
    
    return {
        "count": len(sizes),
        "total_size": total_size,
        "total_size_human": format_size(total_size),
        "avg_size": avg_size,
        "avg_size_human": format_size(avg_size),
        "min_size": min(sizes),
        "min_size_human": format_size(min(sizes)),
        "max_size": max(sizes),
        "max_size_human": format_size(max(sizes)),
        "median_size": calculate_median(sizes),
        "median_size_human": format_size(calculate_median(sizes))
    }


def attachment_stats(attachment_counts: Counter, attachment_sizes: Dict[str, List[int]]) -> Dict[str, Any]:
    """
    Calculate statistics about email attachments.
    
    Args:
        attachment_counts: Counter of attachment types
        attachment_sizes: Dictionary of attachment sizes by type
        
    Returns:
        dict: Statistics about email attachments
    """
    if not attachment_counts:
        return {}
    
    total_attachments = sum(attachment_counts.values())
    stats_result = {
        "total_count": total_attachments,
        "unique_types": len(attachment_counts),
        "by_type": []
    }
    
    for ext, count in attachment_counts.most_common():
        sizes = attachment_sizes.get(ext, [])
        total_size = sum(sizes) if sizes else 0
        
        stats_result["by_type"].append({
            "type": ext,
            "count": count,
            "percentage": (count / total_attachments) * 100,
            "total_size": total_size,
            "total_size_human": format_size(total_size),
            "avg_size": total_size / count if count > 0 else 0,
            "avg_size_human": format_size(total_size / count) if count > 0 else "0 B"
        })
    
    return stats_result


def missing_header_stats(missing_headers: Counter) -> Dict[str, Any]:
    """
    Calculate statistics about missing email headers.
    
    Args:
        missing_headers: Counter of missing header types
        
    Returns:
        dict: Statistics about missing headers
    """
    if not missing_headers:
        return {}
    
    return {
        "total_count": sum(missing_headers.values()),
        "by_type": [{"header": h, "count": c} for h, c in missing_headers.most_common()]
    }


def date_distribution_stats(date_dist: Dict[str, int]) -> Dict[str, Any]:
    """
    Calculate statistics about email date distribution.
    
    Args:
        date_dist: Dictionary of email counts by date (format: 'YYYY-MM')
        
    Returns:
        dict: Statistics about email date distribution
    """
    if not date_dist:
        return {}
    
    busiest_month, busiest_count = max(date_dist.items(), key=lambda x: x[1])
    
    monthly_average = sum(date_dist.values()) / len(date_dist)
    
    return {
        "first_month": min(date_dist.keys()),
        "last_month": max(date_dist.keys()),
        "total_months": len(date_dist),
        "busiest_month": busiest_month,
        "busiest_month_count": busiest_count,
        "monthly_average": monthly_average,
        "monthly_median": calculate_median(list(date_dist.values()))
    }


def size_comparison_stats(original_size: int, parsed_data_size: int) -> Dict[str, Any]:
    """
    Calculate comparison statistics between original file size and parsed data size.
    
    Args:
        original_size: Size of the original file in bytes
        parsed_data_size: Size of the parsed data in bytes
        
    Returns:
        dict: Size comparison statistics
    """
    difference = original_size - parsed_data_size
    difference_percentage = ((original_size - parsed_data_size) / original_size) * 100 if original_size > 0 else 0
    
    return {
        "original_file_size": original_size,
        "original_file_size_human": format_size(original_size),
        "parsed_data_size": parsed_data_size,
        "parsed_data_size_human": format_size(parsed_data_size),
        "difference": difference,
        "difference_human": format_size(difference),
        "difference_percentage": difference_percentage
    }


def calculate_parsed_data_size(body_sizes: Dict[str, List[int]], attachment_sizes: Dict[str, List[int]]) -> int:
    """
    Calculate the total size of all parsed data.
    
    Args:
        body_sizes: Dictionary with body sizes by type (plain_text, html)
        attachment_sizes: Dictionary with attachment sizes by type
        
    Returns:
        int: Total size in bytes
    """
    total_size = 0
    
    # Add plain text sizes
    total_size += sum(body_sizes.get("plain_text", []))
    
    # Add HTML sizes
    total_size += sum(body_sizes.get("html", []))
    
    # Add attachment sizes
    for sizes in attachment_sizes.values():
        total_size += sum(sizes)
        
    return total_size


def calculate_statistics(report_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Calculate and combine all statistical data from report.
    
    Args:
        report_data: Dictionary containing the email analysis data
        
    Returns:
        dict: Combined statistics
    """
    stats_result = {}
    
    # Email count statistics
    if "file_metadata" in report_data and "email_count" in report_data["file_metadata"]:
        stats_result.update(email_count_stats(report_data["file_metadata"]["email_count"]))
    
    # From address statistics
    if "headers" in report_data and "from" in report_data["headers"]:
        stats_result.update(sender_stats(report_data["headers"]["from"]))
    
    # To address statistics
    if "headers" in report_data and "to" in report_data["headers"]:
        stats_result.update(recipient_stats(report_data["headers"]["to"]))
    
    # Body size statistics
    if "content" in report_data and "body_sizes" in report_data["content"]:
        body_sizes = report_data["content"]["body_sizes"]
        
        plain_text_sizes = body_sizes.get("plain_text", [])
        if plain_text_sizes:
            stats_result["plain_text_body"] = body_size_stats(plain_text_sizes, "plain_text")
        
        html_sizes = body_sizes.get("html", [])
        if html_sizes:
            stats_result["html_body"] = body_size_stats(html_sizes, "html")
    
    # Attachment statistics
    if "content" in report_data and "attachments" in report_data["content"]:
        attachment_counts = report_data["content"]["attachments"].get("counts_by_type", Counter())
        attachment_sizes = report_data["content"]["attachments"].get("sizes_by_type", defaultdict(list))
        
        if attachment_counts:
            stats_result["attachments"] = attachment_stats(attachment_counts, attachment_sizes)
    
    # Missing headers statistics
    if "headers" in report_data and "missing_headers" in report_data["headers"]:
        missing_headers = report_data["headers"]["missing_headers"]
        if missing_headers:
            stats_result["missing_headers"] = missing_header_stats(missing_headers)
    
    # Date distribution statistics
    if "headers" in report_data and "date_distribution" in report_data["headers"]:
        date_dist = report_data["headers"]["date_distribution"]
        if date_dist:
            stats_result["date_distribution"] = date_distribution_stats(date_dist)
    
    # Size comparison statistics
    if "file_metadata" in report_data and "file_size" in report_data["file_metadata"] and "content" in report_data:
        original_size = report_data["file_metadata"]["file_size"]
        
        # Calculate parsed data size
        body_sizes = report_data["content"].get("body_sizes", {})
        attachment_sizes = report_data["content"].get("attachments", {}).get("sizes_by_type", {})
        parsed_data_size = calculate_parsed_data_size(body_sizes, attachment_sizes)
        
        stats_result["size_comparison"] = size_comparison_stats(original_size, parsed_data_size)
    
    return stats_result

